const { getRedisClient } = require('../redis/client');
const { v4: uuidv4 } = require('uuid');
const { logger } = require('../logger');

/**
 * Get stream name for entity type
 * @param {string} entityType - Entity type (e.g., 'product', 'price', 'stock')
 * @returns {string} Stream name (e.g., 'product_changes')
 */
function getStreamName(entityType) {
  return `${entityType}_changes`;
}

/**
 * Remove existing stream entries for a specific entity
 * Scans recent entries and removes any with matching entity_id
 * This ensures only the latest update is in the stream
 * @param {string} entityType - Entity type
 * @param {string} entityId - Entity ID to remove entries for
 * @param {number} scanLimit - Maximum number of entries to scan (default: 1000)
 * @returns {Promise<number>} Number of entries removed
 */
async function removeExistingStreamEntries(entityType, entityId, scanLimit = 1000) {
  try {
    const redis = getRedisClient();
    const streamName = getStreamName(entityType);

    // Read recent entries from the stream (most recent first)
    const results = await redis.xrevrange(streamName, '+', '-', 'COUNT', scanLimit);

    if (!results || results.length === 0) {
      return 0;
    }

    // Find entry IDs that match the entity_id
    const entryIdsToDelete = [];
    for (const [id, fields] of results) {
      // Convert fields array [key1, val1, key2, val2, ...] to object
      const entryFields = {};
      for (let i = 0; i < fields.length; i += 2) {
        entryFields[fields[i]] = fields[i + 1];
      }

      // Check if entity_id matches
      if (entryFields.entity_id === entityId) {
        entryIdsToDelete.push(id);
      }
    }

    if (entryIdsToDelete.length === 0) {
      return 0;
    }

    // Delete all matching entries
    if (entryIdsToDelete.length > 0) {
      await redis.xdel(streamName, ...entryIdsToDelete);
    }

    logger.info('Removed existing stream entries', {
      streamName,
      entityType,
      entityId,
      removedCount: entryIdsToDelete.length,
      entryIds: entryIdsToDelete,
    });

    return entryIdsToDelete.length;
  } catch (error) {
    logger.error('Remove existing stream entries error', {
      entityType,
      entityId,
      error: error.message,
    });
    return 0;
  }
}

/**
 * Add or replace entry in Redis Stream
 * Removes any existing entries for the same entity, then adds the new entry
 * This ensures only the latest update per entity is in the stream
 * @param {string} entityType - Entity type
 * @param {string} entityId - Entity ID
 * @param {string} dataHash - SHA-256 hash of data field
 * @param {string} version - Entity version number
 * @param {string} idempotencyKey - Optional idempotency key (generated if not provided)
 * @param {boolean} replaceExisting - If true, remove existing entries for this entity before adding (default: true)
 * @returns {Promise<string|null>} Stream ID (timestamp-sequence) or null if failed
 */
async function addStreamEntry(entityType, entityId, dataHash, version, idempotencyKey = null, replaceExisting = true) {
  try {
    const redis = getRedisClient();
    const streamName = getStreamName(entityType);

    // Remove existing entries for this entity if replaceExisting is true
    let removedCount = 0;
    if (replaceExisting) {
      removedCount = await removeExistingStreamEntries(entityType, entityId);
    }

    // Generate idempotency key if not provided
    const idempotency = idempotencyKey || uuidv4();

    // Add entry to stream
    // Stream ID is auto-generated by Redis (timestamp-sequence format)
    const streamId = await redis.xadd(
      streamName,
      '*', // Auto-generate stream ID
      'entity_type',
      entityType,
      'entity_id',
      entityId,
      'data_hash',
      dataHash,
      'version',
      version,
      'idempotency_key',
      idempotency
    );

    logger.info('Stream entry added', {
      streamName,
      streamId,
      entityType,
      entityId,
      dataHash,
      version,
      idempotencyKey: idempotency,
      replacedExisting: replaceExisting,
      removedCount,
    });

    return streamId;
  } catch (error) {
    logger.error('Stream entry add error', {
      entityType,
      entityId,
      error: error.message,
    });
    return null;
  }
}

/**
 * Read stream entries since last ID
 * @param {string} entityType - Entity type
 * @param {string} lastId - Last stream ID to read from (use '0-0' for all entries)
 * @param {number} limit - Maximum number of entries to read (default: 100)
 * @returns {Promise<Array>} Array of stream entries with format: {id, fields: {entity_type, entity_id, data_hash, version, idempotency_key}}
 */
async function readStreamEntries(entityType, lastId = '0-0', limit = 100) {
  try {
    const redis = getRedisClient();
    const streamName = getStreamName(entityType);

    // Read stream entries
    const results = await redis.xread('COUNT', limit, 'STREAMS', streamName, lastId);

    if (!results || results.length === 0) {
      return [];
    }

    // Parse results
    const entries = [];
    for (const [, streamEntries] of results) {
      for (const [id, fields] of streamEntries) {
        // Convert fields array [key1, val1, key2, val2, ...] to object
        const entryFields = {};
        for (let i = 0; i < fields.length; i += 2) {
          entryFields[fields[i]] = fields[i + 1];
        }

        entries.push({
          id,
          fields: entryFields,
        });
      }
    }

    return entries;
  } catch (error) {
    logger.error('Stream read error', {
      entityType,
      lastId,
      error: error.message,
    });
    return [];
  }
}

/**
 * Read multiple streams since their respective last IDs
 * @param {Object<string, string>} lastIds - Object mapping entityType to lastId (e.g., {product: '1234567890-0', price: '1234567891-0'})
 * @param {number} limit - Maximum number of entries per stream
 * @returns {Promise<Object<string, Array>>} Object mapping entityType to array of entries
 */
async function readMultipleStreams(lastIds, limit = 100) {
  try {
    const redis = getRedisClient();
    const streamNames = [];
    const streamLastIds = [];

    // Prepare stream names and last IDs
    for (const [entityType, lastId] of Object.entries(lastIds)) {
      streamNames.push(getStreamName(entityType));
      streamLastIds.push(lastId || '0-0');
    }

    if (streamNames.length === 0) {
      return {};
    }

    // Read all streams
    const results = await redis.xread('COUNT', limit, 'STREAMS', ...streamNames, ...streamLastIds);

    if (!results || results.length === 0) {
      return {};
    }

    // Parse results
    const streamsData = {};
    for (const [streamName, streamEntries] of results) {
      // Extract entity type from stream name (remove '_changes' suffix)
      const entityType = streamName.replace('_changes', '');

      streamsData[entityType] = [];
      for (const [id, fields] of streamEntries) {
        // Convert fields array to object
        const entryFields = {};
        for (let i = 0; i < fields.length; i += 2) {
          entryFields[fields[i]] = fields[i + 1];
        }

        streamsData[entityType].push({
          id,
          fields: entryFields,
        });
      }
    }

    return streamsData;
  } catch (error) {
    logger.error('Multiple streams read error', {
      lastIds,
      error: error.message,
    });
    return {};
  }
}

/**
 * Trim stream to keep only recent entries
 * @param {string} entityType - Entity type
 * @param {number} maxLength - Maximum number of entries to keep
 * @returns {Promise<number>} Number of entries removed
 */
async function trimStream(entityType, maxLength) {
  try {
    const redis = getRedisClient();
    const streamName = getStreamName(entityType);

    // Trim stream using MAXLEN (approximate)
    const removed = await redis.xtrim(streamName, 'MAXLEN', '~', maxLength);

    logger.info('Stream trimmed', {
      streamName,
      maxLength,
      removed,
    });

    return removed;
  } catch (error) {
    logger.error('Stream trim error', {
      entityType,
      maxLength,
      error: error.message,
    });
    return 0;
  }
}

/**
 * Get stream length
 * @param {string} entityType - Entity type
 * @returns {Promise<number>} Number of entries in stream
 */
async function getStreamLength(entityType) {
  try {
    const redis = getRedisClient();
    const streamName = getStreamName(entityType);

    const length = await redis.xlen(streamName);
    return length;
  } catch (error) {
    logger.error('Stream length error', {
      entityType,
      error: error.message,
    });
    return 0;
  }
}

/**
 * Get last stream entry ID
 * @param {string} entityType - Entity type
 * @returns {Promise<string|null>} Last stream ID or null if stream is empty
 */
async function getLastStreamId(entityType) {
  try {
    const redis = getRedisClient();
    const streamName = getStreamName(entityType);

    // Get last entry using XREVRANGE with COUNT 1
    const results = await redis.xrevrange(streamName, '+', '-', 'COUNT', 1);

    if (!results || results.length === 0) {
      return null;
    }

    // Return the ID of the last entry
    return results[0][0];
  } catch (error) {
    logger.error('Get last stream ID error', {
      entityType,
      error: error.message,
    });
    return null;
  }
}

/**
 * Get stream info (length, first ID, last ID)
 * @param {string} entityType - Entity type
 * @returns {Promise<object|null>} Stream info object or null if stream doesn't exist
 */
async function getStreamInfo(entityType) {
  try {
    const redis = getRedisClient();
    const streamName = getStreamName(entityType);

    const length = await getStreamLength(entityType);
    if (length === 0) {
      return {
        length: 0,
        firstId: null,
        lastId: null,
      };
    }

    // Get first entry
    const firstResults = await redis.xrange(streamName, '-', '+', 'COUNT', 1);
    const firstId = firstResults && firstResults.length > 0 ? firstResults[0][0] : null;

    // Get last entry
    const lastId = await getLastStreamId(entityType);

    return {
      length,
      firstId,
      lastId,
    };
  } catch (error) {
    logger.error('Get stream info error', {
      entityType,
      error: error.message,
    });
    return null;
  }
}

module.exports = {
  getStreamName,
  addStreamEntry,
  removeExistingStreamEntries,
  readStreamEntries,
  readMultipleStreams,
  trimStream,
  getStreamLength,
  getLastStreamId,
  getStreamInfo,
};
